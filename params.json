{"name":"FunctionalJS","body":"*FunctionalJS* is a set of extensions to the `Function` class that allow for a\r\nmore functional programming style.\r\n\r\n\r\nHow To Use\r\n----------\r\n\r\n*FunctionalJS* is not a single utility, but rather a set of related language\r\nenhancements that allow for a different programming style, so there is no\r\nspecific use case for *FunctionalJS* as a whole. However, the documentation for\r\neach of the methods provided by *FunctionalJS* is listed below.\r\n\r\n\r\nClass Methods\r\n-------------\r\n\r\n### Function.\\_ (\\[index\\])\r\nThe underscore function accesses successive arguments of the function in which\r\nit is called. If a number is given as an argument, the argument at that index\r\nis returned and the internal pointer is not advanced.\r\n\r\nThe underscore function can also be passed to `Function::partial` as the\r\nplaceholder for undefined arguments rather than passing `undefined`.\r\n\r\n    var fn = function(a){\r\n        return [_(),_(3),_(),_(),_(0),_(),_()];\r\n    }\r\n    fn(1,2,3,4)    // [1,4,2,3,1,4,undefined]\r\n\r\n### Function.empty ⇒ undefined\r\nReturns `undefined` for any given value. Useful when overriding another\r\nfunction and desiring no action.\r\n\r\n    Function.empty()        // undefined\r\n    Function.empty(\"\")      // undefined\r\n    Function.empty(2)       // undefined\r\n    Function.empty(null)    // undefined\r\n    Function.empty(true)    // undefined\r\n\r\n### Function.identity (*args) ⇒ value\r\nReturns whatever it is given. When many arguments are given, returns an array\r\ncontaining those values. Useful when a function is expected and one would like\r\nto pass a constant value.\r\n\r\n    Function.identity(0)                 // 0\r\n    Function.identity(\"str\")             // \"str\"\r\n    Function.identity(undefined)         // undefined\r\n    Function.identity(null)              // null\r\n    Function.identity(function a(){})    // <#Function:a>\r\n    Function.identity()                  // undefined\r\n    Function.identity(0,1,2)             // [0,1,2]\r\n    Function.identity(0,undefined)       // [0,undefined]\r\n\r\n### Function.context ⇒ this\r\nA function that returns its context (the `this` value).\r\n\r\n    Function.context()            // global scope object, likely window\r\n    Function.context.call(1,2)    // 1\r\n\r\n### Function.lambda (value) ⇒ function() ⇒ value\r\nReturns a function that returns **value**.\r\n\r\n    var fn = Function.lambda(\"lambda\")    // <#Function:fn>\r\n    fn()         // \"lambda\"\r\n    fn(false)    // \"lambda\"\r\n    fn(18)       // \"lambda\"\r\n\r\n### Function.pluck (property) ⇒ function(obj) ⇒ obj[property]\r\nReturns a function that returns the property of the passed object referenced by\r\n**property**.\r\n\r\n    var arr = [[0],[1,2,3],[2,3]],\r\n        len = Function.pluck('length')\r\n    arr.map(Function.pluck(0))        // [0,1,2]\r\n    arr.map(Function.pluck(1))        // [undefined,2,3]\r\n    arr.map(len)                      // [1,3,2]\r\n    len(arr)                          // 3\r\n    len(\"string\")                     // 6\r\n    len({test:\"abc\",length:\"def\"})    // \"def\"\r\n\r\n### Function.invoke (method, \\*defaultArg) ⇒ function(obj)\r\nReturns a function that calls the method referenced by **method** of **obj**.\r\nAny additional arguments passed to `Function.invoke` will be used as the\r\ndefault arguments to be passed to the given method by the generated function.\r\nAny arguments passed to the generated function beyond the first will be passed\r\nto the function it calls instead of passing the default arguments.\r\n\r\n    var now   = Function.invoke('now'),\r\n        first = Function.invoke(0,'a'),\r\n        obj   = {now:Function.identity},\r\n        arr   = [Function.identity];\r\n    now(Date)         // <the current date>\r\n    now(obj,0,1,2)    // [0,1,2]\r\n    first(arr)        // 'a'\r\n    first(arr,'b')    // 'b'\r\n\r\n### Function.sequence (\\*fn) ⇒ function(\\*arg)\r\nCreates a function that calls the first passed function on the first call, the\r\nsecond passed function on the next call (if one was passed), and so on. The\r\nlast function is treated as if it proceeds the first function. Arguments passed\r\nto the generated function are passed to the original functions. The return\r\nvalue is the return value of the original function. When called with no\r\narguments, Function.sequence returns Function.empty.\r\n\r\n    var fn1 = function(){ return 1; },\r\n        fn2 = function(){ return 2; },\r\n        fn3 = function(){ return 3; },\r\n        seq = Function.sequence(fn1,fn2,fn3);\r\n    seq()    // 1\r\n    seq()    // 2\r\n    seq()    // 3\r\n    seq()    // 1\r\n    seq()    // 2\r\n\r\n### Function.concat\\[enate\\] (\\*fn) ⇒ function(\\*arg)\r\nCreates a function that runs all functions passed to `Function.concat`\r\nsequentially. The return value of the last function is returned by the\r\ngenerated function. Arguments given to the generated function are passed to all\r\nfunctions.\r\n\r\n    var sharedArr = [],\r\n        fnA = function(){ sharedArr.push('A'); return 0; },\r\n        fnB = function(){ sharedArr.push('B'); return 1; },\r\n        fnC = function(_){ sharedArr.push(_+23); return 2; }\r\n    Function.concat(fnA,fnB,fnC)(100)    // 2\r\n    sharedArr                            // ['A','B',123]\r\n\r\n### Function.compose (\\*fn) ⇒ function(\\*arg)\r\nCreates a function that runs all functions passed in reverse order, passing the\r\nreturn value of the last function run as the input to the next function. Any\r\narguments given to the generated function will be passed to the first function\r\ncalled.\r\n\r\n    var a = function(str){ return 'a'+str; },\r\n        b = function(str){ return 'b'+str; },\r\n        c = function(str1,str2){ return 'c'+str1+str2+'f'; },\r\n        fn = Function.compose(a,b,c)\r\n    fn('d','e')    // \"abcde\"\r\n\r\n### Function.overload (\\*fn) ⇒ function(\\*arg)\r\nIf an object having numeric keys is given as the sole argument, returns a\r\nfunction that will call the function indexed by the number of arguments passed\r\nto it. If a list of functions is given as arguments, returns a function that\r\ncalls the last function given that has an arity of the number of arguments\r\npassed to the returned function.\r\n\r\n    var fnA = function(){ return 'A'; },\r\n        fnB = function(x){ return 'B'; },\r\n        fnC = function(y,y){ return 'C'; },\r\n        fnD = funciton(z,z,z){ return 'D'; }\r\n    var overloaded = Function.overload(fnA,fnB,fnC,fnD)  // <#Function:overloaded>\r\n    overload()           // 'A'\r\n    overload(0,0)        // 'C'\r\n    overload(0,0,0,0)    // undefined\r\n\r\n    overloaded = Function.overload({\r\n        0:fnD, 1:fnC, 2:fnB, 8:fnA\r\n    })\r\n    overloaded(0)                        // 'C'\r\n    overloaded(0,0,0)                    // undefined\r\n    overloaded.apply({},new Array(8))    // 'A'\r\n\r\n### Function.and (\\*fn) ⇒ function(\\*arg)\r\nReturns a function that returns the result of performing a Boolean AND\r\noperation on the return values of all functions passed to `Function.and`.\r\nArguments given to the generated function will be passed to the called\r\nfunctions. Short-circuit evaluation logic is applied. When only a single\r\nfunction is given to `Function.and`, the Boolean interpretation of the return\r\nvalue of that function is returned. When no arguments are given, returns\r\n`Function.empty`.\r\n\r\n    var fnTrue = Function.lambda(true),\r\n        fnFalse = Function.lambda(false);\r\n    Function.and()()                   // undefined\r\n    Function.and(fnTrue)()             // true\r\n    Function.and(fnFalse)()            // false\r\n    Function.and(fnTrue,fnFalse)()     // false\r\n    Function.and(fnFalse,fnFalse)()    // false\r\n    Function.and(fnTrue,fntrue)()      // true\r\n\r\n### Function.or (\\*fn) ⇒ function(\\*arg)\r\nBehaves exactly as `Function.and`, except uses Boolean *OR* logic instead of\r\nBoolean *AND* logic.\r\n\r\n### Function.xor (\\*fn) ⇒ function(\\*arg)\r\nBehaves as `Function.and` and `Function.or`, except uses Boolean *XOR* logic\r\nand does not short-circuit.\r\n\r\n\r\nInstance Methods\r\n----------------\r\n\r\n### toFunction ⇒ this\r\nReturns the function upon which `toFunction` is called.\r\n\r\n### wrap (fn, \\[bind\\]) ⇒ function(\\*arg)\r\nReturns a function that calls **fn**, passing to it this function instance as\r\nthe first argument and the arguments given to the generated function as the\r\nsecond argument.\r\n\r\nIn other words, it wraps this Function instance in **fn**. The arguments given\r\nto the generated function (the wrapper function) are the function upon which\r\n`wrap` is called and the arguments object from the generated function (as an\r\narray).\r\n\r\nAn optional second argument may be given, which binds the function upon which\r\n`wrap` is called to **bind**.\r\n\r\nExamples of usage taken from the source:\r\n\r\n    Function.implement({\r\n        curry: function(){\r\n            var curriedArgs = Array.prototype.slice.call(arguments);\r\n            return this.wrap(function(original,passedArgs){\r\n                return original.apply(this,curriedArgs.concat(passedArgs));\r\n            });\r\n        },\r\n\r\n        not: function(){\r\n            if(arguments.length) return this.not().apply(this,arguments);\r\n            return this.wrap(function(fn,args){\r\n                return !fn.apply(this,args);\r\n            });\r\n        }\r\n    });\r\n\r\n### getOrigin ⇒ function(\\*arg)\r\n*Note: All Function instance methods defined in FunctionalJS that return a function use `wrap` to create it; you should, too!*\r\nWhen called on functions passed through `wrap`, `getOrigin` returns the value\r\nreturned when `getOrigin` is applied to the function on which `wrap` was\r\noriginally called.  Otherwise, `getOrigin` acts like `Function.context` and\r\nreturns the function upon which it is called. This essentially walks the chain\r\nof wrapped functions to find the original function with none of the\r\nmodifications applied to it.\r\n\r\n    var fn = function(a,b){ return a+b; },\r\n        notted = fn.not(),\r\n        curried = notted.curry(2);\r\n\r\n    notted.getOrigin()            // <#Function:fn>\r\n    notted === fn                 // false\r\n    notted.getOrigin() === fn     // true\r\n    curried.getOrigin() === fn    // true\r\n\r\n### memoize (\\[memos\\]) ⇒ function(*args)\r\n*Note: Objects are compared using exact equality (`===`), arrays are considered equal if their contents are equal*\r\n\r\nReturns a memoized version of the function upon which memoize is called.  The\r\nmemoized function keeps track of return values and the inputs that generated\r\nthem, causing a faster, cached response the next time the same set of inputs is\r\ngiven. The unique key used to determine if a return value exists is the set of\r\nthe context (the `this` value) and all arguments passed to the memoized\r\nfunction.\r\n\r\nThe internal memo collection can be initialized by passing one or more\r\nspecially formatted objects containing a set of predetermined inputs and\r\noutputs as the first argument to `memoize` (**memos**). The object must have a\r\n`returnValue` property, and may have `context` and `args` properties. The\r\n`returnValue` property specifies the value returned by the generated function\r\non a cache hit. The `context` property defines the context that must be\r\nmatched, and the `args` property defines the arguments that must be matched for\r\na cache hit. The context or args values, if undefined, will match any context\r\nor arguments.  The `args` value can either be a single value or an array\r\ncontaining zero or more values.\r\n\r\n    var tFunction = Function.lambda(true),\r\n        defs = [\r\n            {args: 3, returnValue: false},\r\n            {args: [1,2], returnValue: false}\r\n        ]\r\n        memoized = tFunction.memoize(defs);\r\n\r\n    memoized()       // true\r\n    memoized(1)      // true\r\n    memoized(1,2)    // false\r\n    memoized(2,1)    // true\r\n    memoized(2)      // true\r\n    memoized(3)      // false\r\n    tFunction(3)     // true\r\n\r\n### traced ([name, [opts]]) ⇒ function(\\*args)\r\nWraps the function upon which `trace` is called so that it logs useful\r\ninformation to the console (according to **opts**) whenever it is called. If a\r\nnon-falsey value is given for **name**, it will be used in the console's group\r\nname. The available options for `traced` are:\r\n\r\n* Function.TRACE\\_NONE\r\n  Will cause the traced function to only log that it was called.\r\n* Function.TRACE\\_ALL\r\n  Will cause the traced function to act as if all options were enabled.\r\n* Function.TRACE\\_ARGUMENTS\r\n  Will log the arguments passed to the traced function.\r\n* Function.TRACE\\_CONTEXT\r\n  Will log the context (`this` value) of the traced function.\r\n* Function.TRACE\\_RETURN\r\n  Will log the return value of the traced function.\r\n* Function.TRACE\\_TIME\r\n  Will log the time it takes to run the function.\r\n* Function.TRACE\\_STACK\r\n  Will log a stack trace.\r\n\r\n**opts** may be the bitwise OR of any of these options. **opts** defaults to\r\n`Function.TRACE_ARGUMENTS | Function.TRACE_RETURN`. \r\n\r\n    var fn1 = function(){},\r\n        traced1 = fn1.traced('fn1');\r\n    traced1();\r\n\r\n    var fn2 = function funcTwo(){},\r\n        traced2 = fn2.traced(undefined,Function.TRACE_ALL);\r\n    traced2();\r\n\r\n    var fn3 = function(){},\r\n        traced3 = fn3.traced('fn3',Function.TRACE_RETURN | Function.TRACE_CONTEXT);\r\n    traced3();\r\n\r\n### partial (\\*args) ⇒ function(\\*args)\r\n*Note: Function.\\_ is defined as \\_ in the global scope*\r\n\r\nCreates a partially applied function that has any passed arguments that are not\r\n`undefined` or `Function._` bound in the position they are given. The returned\r\nfunction accepts any unbound arguments.\r\n\r\n    var fn = function(){ return [].slice.call(arguments); }\r\n    var part = fn.partial(1,undefined,_,4)      // <#Function:part>\r\n    part(2,3,5)                                 // [1,2,3,4,5]\r\n\r\n### curry (\\*args) ⇒ function(\\*args)\r\nA simplified `Function::partial`. Creates a partially applied function that has\r\nthe arguments given to `curry` bound to its leftmost arguments in the order in\r\nwhich they are given.\r\n\r\n    var fn = function(){ return [].slice.call(arguments); }\r\n    var some = fn.curry(1,2)        // <#Function:some>\r\n    some()                          // [1,2]\r\n    var most = some.curry(3)        // <#Function:most>\r\n    var all = most(4,5)             // [1,2,3,4,5]\r\n\r\n### rcurry (\\*args) ⇒ function(\\*args)\r\nCreates a partially applied function that has the arguments given to `rcurry`\r\nbound to its rightmost arguments in the order in which they are given.\r\n\r\n    var fn = function(){ return [].slice.call(arguments); }\r\n    var some = fn.rcurry(4,5)       // <#Function:some>\r\n    some()                          // [4,5]\r\n    var most = some.rcurry(3)       // <#Function:most>\r\n    var all = most(1,2)             // [1,2,3,4,5]\r\n\r\n### not (\\*args) ⇒ mixed\r\nWhen called with no arguments, returns a function that returns the opposite\r\nBoolean representation of the return value of the function upon which `not` is\r\ncalled. When arguments are passed to `not`, the opposite Boolean representation\r\nof the return value of the function upon which `not` is called when passed\r\nthose arguments is returned.\r\n\r\n    var powerOfTwo = function(n){ return n>0 && !(n&(n-1)); }\r\n    var notted = powerOfTwo.not()   // <#Function:notted>\r\n    powerOfTwo(2)        // true\r\n    notted(2)            // false\r\n    powerOfTwo(5)        // false\r\n    powerOfTwo.not(5)    // true\r\n\r\n### append (\\*fn) ⇒ function(\\*args)\r\nReturns a new function that runs the given function(s) after running the\r\nfunction upon which `append` was called. Any arguments passed to the generated\r\nfunction will be passed to all functions. The return value of the generated\r\nfunction is the return value of the function upon which `append` was called.\r\n\r\n    var sharedArr = [],\r\n        fnA = function(){ sharedArr.push(0); return 0; },\r\n        fnB = function(){ sharedArr.push(1); return 1; },\r\n        fnC = function(){ sharedArr.push(2); return 2; },\r\n\r\n    var fnAB = fnA.append(fnB),\r\n        fnBC = fnB.append(fnC),\r\n        fnABC = fnA.append(fnB,fnC);\r\n    fnA()        // 0\r\n    sharedArr    // [0]\r\n    fnAB()       // 0\r\n    sharedArr    // [0,0,1]\r\n    fnBC()       // 1\r\n    sharedArr    // [0,0,1,1,2]\r\n    fnABC()      // 0\r\n    sharedArr    // [0,0,1,1,2,0,1,2]\r\n\r\n### prepend (\\*fn) ⇒ function(\\*args)\r\nReturns a new function that runs the given function(s) before running the\r\nfunction upon which `prepend` was called. Any arguments passed to the generated\r\nfunction will be passed to all functions. The return value of the generated\r\nfunction is the return value of the function upon which `prepend` was called.\r\n\r\n    var sharedArr = [],\r\n        fnA = function(_){ sharedArr.push(0+_); return 0; },\r\n        fnB = function(_){ sharedArr.push(1+_); return 1; },\r\n        fnC = function(_){ sharedArr.push(2+_); return 2; },\r\n\r\n    var fnAB = fnB.prepend(fnA),\r\n        fnBC = fnC.prepend(fnB),\r\n        fnABC = fnC.prepend(fnA,fnB);\r\n    fnA(0)       // 0\r\n    sharedArr    // [0]\r\n    fnAB(1)      // 1\r\n    sharedArr    // [0,1,2]\r\n    fnBC(2)      // 2\r\n    sharedArr    // [0,1,2,3,4]\r\n    fnABC(3)     // 2\r\n    sharedArr    // [0,1,2,3,4,3,4,5]\r\n\r\n### overload (\\[funcTable\\]) ⇒ function(\\*args)\r\nIf a numerically indexed object containing functions is given as the only\r\nargument, the function upon which `overload` is called is added to the object\r\n(indexed by its arity) and the object is passed to `Function.overload`. If a\r\nlist of functions is given, the function upon which `overload` is called is\r\nappended to the list and the list is passed to `Function.overload`. In either\r\ncase, the return value of `Function.overload` is returned.\r\n\r\n    var fnA = function(){ return \"A\"; },\r\n        fnB = function(b){ return \"B\"; },\r\n        fnC = function(){ return \"C\"; }\r\n    fnA.overload(fnB,fnC)()             // \"A\"\r\n    fnA.overload({1:fnB,2:fnC})(0)      // \"B\"\r\n    fnC.overload(fnA,fnB)()             // \"C\"\r\n\r\n### saturate (*args) ⇒ function()\r\nReturns a function that fixes the arguments passed to `saturate` to the\r\nfunction upon which it is called. Arguments given to the returned function will\r\nbe ignored in favor of the originally passed arguments.\r\n\r\n    Function.identity.saturate(1,2)()         // [1,2]\r\n    Function.identity.saturate(1,2)(3,4)      // [1,2]\r\n    Function.identity.saturate()()            // undefined\r\n    Function.identity.saturate()(1,2)         // undefined\r\n    Function.identity.saturate(1)()           // 1\r\n    Function.identity.saturate(2)(1,2)        // 2\r\n\r\n### aritize (arity) ⇒ function(*args)\r\nIf given a non-negative **arity**, a function that only accepts the first\r\n**arity** arguments is returned. If **arity** is less than zero, a function\r\nthat accepts all but the last **arity** arguments is returned.\r\n\r\n    Function.identity.aritize(2)(0,1,2)       // [0,1]\r\n    Function.identity.aritize(0)(0,1)         // undefined\r\n    Function.identity.aritize(-2)(0,1,2)      // 0\r\n\r\n### getArgs ⇒ array\r\nReturns an array containing the arguments expected by the function upon which\r\n`getArgs` is called.\r\n\r\n    function(one,two){}.getArgs()             // [\"one\",\"two\"]\r\n    function(a,b,c){}.memoize().getArgs()     // [\"a\",\"b\",\"c\"]\r\n    function(){}.getArgs()                    // []\r\n\r\n### getArity ⇒ integer\r\nReturns the number of arguments expected by the function upon which `getArity`\r\nis called.\r\n\r\n    function(one,two){}.getArity()            // 2\r\n    function(a,b,c){}.memoize().getArity()    // 3\r\n    function(){}.getArity()                   // 0\r\n\r\n### Array Methods\r\nThe array methods `forEach`, `each`, `every`, `some`, `filter`, `map`,\r\n`reduce`, `reduceRight`, and `sort` are defined as Function instance methods\r\nthat accept an array as input. `foldl` and `foldr` are implemented as aliases\r\nto `reduce` and `reduceRight`. The function call is translated into the\r\nassociated method call on the array, passing the function upon which the method\r\nwas called as the first argument and any other arguments supplied as successive\r\narguments.\r\n\r\n    var sum = function (a,b){ return a+b; }    // <#Function:sum>\r\n    sum.reduce([1,2,3,4],0)                    // 10\r\n\r\n    var gtZero = function(_){ return _>0; }    // <#Function:gtZero>\r\n    gtZero.every([5,6,7,8])                    // true\r\n\r\n\r\nArray Instance Methods\r\n----------------------\r\n\r\n### Array::toFunction ⇒ function(*args)\r\nReturns a function that returns the value of any property of the array upon\r\nwhich `toFunction` was called. Most useful for accessing the numeric properties\r\nof the array.\r\n\r\n    var arr = ['a','b','c']         // ['a','b','c']\r\n    var fn = arr.toFunction()       // <#Function:fn>\r\n    fn(0)                           // 'a'\r\n    fn(2)                           // 'c'\r\n    fn(3)                           // undefined\r\n    fn('length')                    // 3\r\n\r\n\r\nHash Instance Methods\r\n---------------------\r\n\r\n### Hash::toFunction ⇒ function(*args)\r\nReturns a function that returns the value of any property of the hash upon\r\nwhich `toFunction` was called.\r\n\r\n    var obj = new Hash({a:0,b:1,c:2})   // {a:0,b:1,c:2}\r\n    var fn = obj.toFunction()           // <#Function:fn>\r\n    fn('a')                             // 0\r\n    fn('c')                             // 2\r\n    fn('z')                             // undefined\r\n    fn('hasOwnProperty')                // <#Function:hasOwnProperty>\r\n\r\n\r\nObject Class Methods\r\n--------------------\r\n\r\n### Object.toFunction (obj) ⇒ function(*args)\r\nReturns a function that returns the value of any property of **obj**.\r\n\r\n    var obj = {a:0,b:1,c:2},            // {a:0,b:1,c:2}\r\n        fn = Object.toFunction(obj)     // <#Function:fn>\r\n    fn('a')                             // 0\r\n    fn('c')                             // 2\r\n    fn('z')                             // undefined\r\n    fn('hasOwnProperty')                // <#Function:hasOwnProperty>\r\n\r\n    // Object.toFunction can make a function out of ANY object\r\n    var node = document.createElement('div')         // <#HTMLDivElement:node>\r\n    node.id = 'testID'\r\n    node.style.color = '#EEE'\r\n    var divFunc = Object.toFunction(node)            // <#Function:divFunc>\r\n    var styleFunc = Object.toFunction(node.style)    // <#Function:styleFunc>\r\n    divFunc('id')                                    // \"testID\"\r\n    styleFunc('color')                               // \"#EEE\"\r\n\r\n\r\nGlobals\r\n-------\r\n\r\n### \\_\r\nThe global \\_ function is a short, global reference to Function.\\_.\r\n\r\n\r\nTODO\r\n----\r\n\r\n* document Function::overloadSetter and Function::overloadGetter\r\n* document Function::extend and Function::implement\r\n* document Function::bind\r\n* update source headers, package.yml, and externs.js to reflect new API additions\r\n\r\nKnown Issues\r\n------------\r\n\r\n* The underscore function is broken in chrome, caused by\r\narguments.callee.caller.arguments not returning the same object on separate\r\naccesses. See [V8 Issue 222](http://code.google.com/p/v8/issues/detail?id=222).\r\n\r\n\r\nAdditional Info\r\n---------------\r\n\r\nI am always open for feature requests or any feedback.\r\nI can be reached at [Github](http://github.com/michaelficarra).","tagline":"Extensions to the Function object that allow a more functional programming style","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}